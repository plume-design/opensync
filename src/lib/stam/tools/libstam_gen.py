#!/usr/bin/env python3
import argparse
import os
import re
from collections import OrderedDict
import pydot
import sys

class TransitionKey:
    def __init__(self, src, dest):
        self.src = src
        self.dest = dest

    def __hash__(self):
        return hash((self.src, self.dest))

    def __eq__(self, other):
        return self.src == other.src and self.dest == other.dest


def to_array_name(node, suffix):
    return 'valid_{node.lower()}_{suffix}'.format(locals())


# Bunch of string helpers making names more "C-friendly"
# e.g. to_upper("ab C-D") -> "ab_c_d"
def to_upper(text):
    return re.sub(r'[ .-]', '_', text).upper()


def to_lower(text):
    return re.sub(r'[ .-]', '_', text).lower()


def parse_file(file_path):
    with open(file_path, 'r') as handle:
        data = handle.read()
        graph = pydot.graph_from_dot_data(data)

        # Compatibility with older versions
        if isinstance(graph, list):
            graph = graph[0]

        transactions = {}
        states = OrderedDict()  # I want to keep the order in which 'entry' states appear in DOT file
        all_actions = set()

        for state in graph.get_node_list():
            if state.obj_dict['attributes'].get('init'):
                states[state.get_name()] = None

        # Edge is a state machine transition
        for edge in graph.get_edges():
            # Extract action names from "label" property
            actions = edge.obj_dict['attributes'].get('label', str()).strip('"').split(',')
            actions = set([action for action in actions if action != ''])
            all_actions |= actions

            # We need to know all actions to generate enum
            if edge.get_destination() == "EXCEPTION":
                # The exception state is a special case -- it's implicit when
                # an "exception" list is defined.
                # Ignore any state transitions to the EXCEPTION state as those
                # are probably just placeholders for generating the EXCEPTION
                # list

                # Verify that all actions leading to the EXCEPTION state are
                # exceptions (the ! syntax)
                for a in actions:
                    if not a.startswith('!'):
                        raise Exception("Action {} leading to EXCEPTION must be defined as an exception (prefix it with !)".format(a))
            else:
                # We need to know all states to generate enum, but ignore the "EXCEPTION" state -- it is autogenerated
                # if needed
                if edge.get_source() != 'EXCEPTION':
                    states[edge.get_source()] = None

                    # Verify that actions are not exceptions (the ! syntax)
                    for a in actions:
                        if a.startswith('!'):
                            raise Exception("Exception {} does not reference the EXCEPTION state.".format(a))

                states[edge.get_destination()] = None

                # DOT allows to define the same transition (e.g. "a -> b") multiple times. libstam doesn't allow that,
                # so we're combining the same transitions.
                key = TransitionKey(edge.get_source(), edge.get_destination())
                if key in transactions:
                    transactions[key] |= actions
                else:
                    transactions[key] = actions

        return states.keys(), transactions, all_actions


def gen_define_states(states):
    buf = '#define STAM_STATES(state) \\\n'
    buf += ' \\\n'.join(['    state({})'.format(to_upper(key)) for key in states])
    return buf


def gen_define_actions(actions):
    buf = '#define STAM_ACTIONS(action) \\\n'
    belem = []
    for key in actions:
        if key == 'STATE_INIT':
            continue

        if key.startswith('!'):
            continue

        belem.append('    action({})'.format(to_upper(key)))

    buf += ' \\\n'.join(belem)
    buf += '\n\n'

    belem = []
    for key in actions:
        if not key.startswith('!'):
            continue

        belem.append('    except({})'.format(to_upper(key[1:])))

    if len(belem) > 0:
        buf += '#define STAM_EXCEPTIONS(except) \\\n'
        buf += ' \\\n'.join(belem)
        buf += '\n\n'

    return buf

def gen_transition_arrays(base_name, transitions):
    actions_buf = ''
    transitions_buf = ''
    for i, key in enumerate(transitions.keys()):
        actions = transitions[key]
        lo_base_name = to_lower(base_name)
        if actions:
            array_name = 'transition_{}_actions'.format(i)

            actions_buf += '/* Actions for {}_{} -> {}_{} */\n'.format(
                    lo_base_name, key.src, lo_base_name, key.dest)
            actions_buf += 'static const int {}[] =\n{{\n'.format(array_name)
            action_list = []
            for action in actions:
                if action.startswith('!'):
                    action_list.append('    {}_exception_{}'.format(lo_base_name, to_upper(action[1:])))
                else:
                    action_list.append('    {}_do_{}'.format(lo_base_name, to_upper(action)))

            actions_buf += ',\n'.join(action_list)
            actions_buf += ',\n    {}_do__END\n'.format(lo_base_name)
            actions_buf += '};\n\n'

            transitions_buf += '    {{ {}_{}, {}_{}, {} }},\n'.format(
                    lo_base_name, to_upper(key.src), lo_base_name, to_upper(key.dest), array_name)
        else:
            transitions_buf += '    {{ {}_{}, {}_{}, NULL }},\n'.format(
                    lo_base_name, to_upper(key.src), lo_base_name, to_upper(key.dest))

    return actions_buf, transitions_buf


def gen_header(
        base_name,
        states,
        actions,
        disable_actions_checks,
        disable_transitions_checks):

    lo_base_name = to_lower(base_name)
    buf = \
        '/* DO NOT EDIT FILE (it was autogenerated)! */\n' \
        '#ifndef {lo_base_name}_GEN_H\n' \
        '#define {lo_base_name}_GEN_H\n' \
        '\n' \
        '#define STAM_NAME {lo_base_name}\n' \
        '\n' \
        '{states}\n' \
        '\n' \
        '{actions}\n' \
        '\n'.format(
                lo_base_name = lo_base_name,
                states = gen_define_states(states),
                actions = gen_define_actions(actions))

    if not disable_actions_checks:
        buf += \
            '#define STAM_actions_checks\n'

    if not disable_transitions_checks:
        buf += \
            '#define STAM_transitions_checks\n'

    buf += '#if !defined(STAM_GENERATE_SOURCE) && !defined(STAM_GENERATE_HEADER)\n'
    buf += '/* By default, generate the header */\n'
    buf += '#define STAM_GENERATE_HEADER\n'
    buf += '#endif\n\n'
    buf += '#include "stam.h"\n\n'

    buf += '#endif /* {}_GEN_H */\n'.format(lo_base_name)
    return buf


def gen_source(base_name, transactions, disable_actions_checks, disable_transitions_checks):
    actions_buf, transactions_buf = gen_transition_arrays(base_name, transactions)

    lo_base_name = to_lower(base_name)

    buf = \
        '/* DO NOT EDIT FILE (it was autogenerated)! */\n' \
        '\n' \
        '#define STAM_GENERATE_HEADER\n' \
        '#define STAM_GENERATE_SOURCE\n' \
        '#include "{}_stam.h"\n' \
        '\n'.format(lo_base_name, lo_base_name)

    if not (disable_actions_checks and disable_transitions_checks):
        # Don't emit any arrays when both actions & transitions verification is disabled. Otherwise
        # compiler will complain about unused variables.
        buf += \
            '{actions_buf}' \
            'static const struct stam_trans valid_transitions[] =\n{{\n' \
            '{transactions_buf}' \
            '    {{ {lo_base_name}__END, {lo_base_name}__END, NULL }}\n' \
            '}};\n' \
            '\n'.format(**locals())

    if not disable_actions_checks:
        buf += 'bool {lo_base_name}_validate_transition(enum {lo_base_name}_state entry_state, enum {lo_base_name}_state exit_state, enum {lo_base_name}_action action)\n' \
               '{{\n' \
               '    /* {lo_base_name}_do_STATE_INIT action is implicitly allowed for all states */\n' \
               '    if (entry_state == exit_state && action == {lo_base_name}_do_STATE_INIT)\n' \
               '        return true;\n\n' \
               '    return stam_validate_relation((int) entry_state, (int) exit_state, (int) action, valid_transitions, (int) {lo_base_name}__END, (int) {lo_base_name}_do__END);\n' \
               '}}\n' \
               '\n'.format(**locals())

    if not disable_transitions_checks:
        buf += \
            'bool {lo_base_name}_validate_action(enum {lo_base_name}_state entry_state, enum {lo_base_name}_action action) \n' \
            '{{\n' \
            '    /* {lo_base_name}_do_STATE_INIT action is implicitly allowed for all states */\n' \
            '    if (action == {lo_base_name}_do_STATE_INIT)\n' \
            '        return true;\n\n' \
            '    return stam_validate_relation((int) entry_state, (int) {lo_base_name}__END, (int) action, valid_transitions, (int) {lo_base_name}__END, (int) {lo_base_name}_do__END);\n' \
            '}}\n'.format(**locals())

    return buf


def get_base_name(dot_file):
    file_name = os.path.basename(dot_file)
    file_name = os.path.splitext(file_name)
    return file_name[0]


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('input_dot', help='DOT file defining FSM')
    parser.add_argument('--header', help='Generate header file', action="store_true")
    parser.add_argument('--source', help='Generate source file', action="store_true")
    parser.add_argument('--stdout', help='Print result on stdout', action="store_true")
    parser.add_argument('--file', help='Write result to file', action="store_true")
    parser.add_argument('--dest', help='Destination directory', type=str, default='.')
    parser.add_argument('--disable-actions-checks', help='Do not verify actions at runtime', action="store_true")
    parser.add_argument('--disable-transitions-checks', help='Do not verify transitions at runtime',
                        action="store_true")

    args = parser.parse_args()
    base_name = get_base_name(args.input_dot)
    states, transactions, actions = parse_file(args.input_dot)

    header = None
    source = None

    if args.header:
        header = gen_header(base_name, states, actions, args.disable_actions_checks, args.disable_transitions_checks)

    if args.source:
        source = gen_source(base_name, transactions, args.disable_actions_checks, args.disable_transitions_checks)

    if args.stdout:
        if header:
            print(header)
        if source:
            print(source)

    if args.file:
        if header:
            file_path = os.path.join(args.dest, '{}_stam.h'.format(base_name))
            with open(file_path, 'w') as handle:
                handle.write(header)
        if source:
            file_path = os.path.join(args.dest, '{}_stam.c'.format(base_name))
            with open(file_path, 'w') as handle:
                handle.write(source)


if __name__ == '__main__':
    main()
