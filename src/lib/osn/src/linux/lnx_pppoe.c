/*
Copyright (c) 2015, Plume Design Inc. All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
   1. Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
   2. Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
   3. Neither the name of the Plume Design Inc. nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Plume Design Inc. BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include <net/if.h>
#include <sys/ioctl.h>

#include <errno.h>
#include <fcntl.h>
#include <string.h>
#include <unistd.h>

#include "const.h"
#include "ds_tree.h"
#include "kconfig.h"
#include "log.h"
#include "osa_assert.h"
#include "osn_types.h"
#include "util.h"

#include "lnx_pppoe.h"
#include "lnx_netlink.h"

#define LNX_PPPOE_PEERS_DIR     CONFIG_OSN_LINUX_PPPOE_ETC_DIR"/peers"
#define LNX_PPPOE_PAP_SECRETS   CONFIG_OSN_LINUX_PPPOE_ETC_DIR"/pap-secrets"
#define LNX_PPPOE_CHAP_SECRETS  CONFIG_OSN_LINUX_PPPOE_ETC_DIR"/chap-secrets"

/* Template for the "peers" (config) file */
const char lnx_pppoe_peers_template[] =
    "#\n"
    "# Autogenerated, do not edit.\n"
    "#\n"
    "# Persist at acquiring the connection\n"
    "persist\n"
    "# Acquire IP from peer\n"
    "noipdefault\n"
    "# Add default route to peer when link is up\n"
    "defaultroute\n"
    "# Hide passwords when logging\n"
    "hide-password\n"
    "# Enable the PPPoE plug-in\n"
    "plugin rp-pppoe.so %s\n"
    "# Peer is not required to authenticate (we're the client, not the server)\n"
    "noauth\n"
    "# Interface name\n"
    "ifname %s\n"
    "# Remote name\n"
    "remotename %s\n"
    "# Get DNS settings from the peer\n"
    "usepeerdns\n"
    "# Disable VJ TCP/IP header compression\n"
    "novj\n"
    "# Disable BSD compression\n"
    "nobsdcomp\n"
    "# Do not fork into background\n"
    "nodetach\n"
    "# Log to file descriptor 2 (stderr)\n"
    "logfd 2\n"
    "# IPv6 support\n"
    "+ipv6\n"
    "ipv6cp-use-persistent\n"
    "# Enable debug logging\n"
    "debug\n";

const char lnx_pppoe_peers_template_username[] =
    "# Username to use\n"
    "user \"%s\"\n";
/*
 * A structure representing a single PPP "secret". A secret is a
 * username/password pair. Secrets must be written to a global file, which is
 * shared by all pppd instances. There's no option to have a per pppd instance
 * file and this is also the reason we must cache this in memory.
 *
 * TODO: Verify username/password maximum length.
 */
struct lnx_pppoe_secret
{
    char           *ps_remote;                      /**< Remote specifier */
    char            ps_username[128];               /**< PPP username */
    char            ps_password[128];               /**< PPP password */
    ds_tree_node_t  ps_tnode;                       /**< Tree node structure */
};

static ds_tree_t lnx_pppoe_secrets = DS_TREE_INIT(ds_str_cmp, struct lnx_pppoe_secret, ps_tnode);

static void lnx_pppoe_secret_del(lnx_pppoe_t *self);
static void lnx_pppoe_secret_update(void);
static bool lnx_pppoe_secret_write(const char *secret_file);
static bool lnx_pppoe_peers_write(lnx_pppoe_t *self);

static void lnx_pppoe_status_poll(lnx_pppoe_t *self);
static lnx_netlink_fn_t lnx_pppoe_netlink_fn;
static bool lnx_pppoe_ifreq(const char *ifname, int cmd, struct ifreq *req);

bool lnx_pppoe_init(lnx_pppoe_t *self, const char *ifname)
{
    memset(self, 0, sizeof(*self));

    if (mkdir(CONFIG_OSN_LINUX_PPPOE_ETC_DIR, 0700) != 0 && errno != EEXIST)
    {
        LOG(WARN, "pppoe: %s: Error creating folder: %s", ifname, CONFIG_OSN_LINUX_PPPOE_ETC_DIR);
    }

    if (mkdir(LNX_PPPOE_PEERS_DIR, 0700) != 0 && errno != EEXIST)
    {
        LOG(WARN, "pppoe: %s: Error creating folder: %s", ifname, LNX_PPPOE_PEERS_DIR);
    }

    STRSCPY_WARN(self->lp_ifname, ifname);

    if (!daemon_init(&self->lp_pppd, CONFIG_OSN_LINUX_PPPOE_BIN, DAEMON_LOG_ALL))
    {
        LOG(ERR, "pppoe: %s: Unable to initialize pppd daemon object.", ifname);
        return false;
    }

    daemon_arg_add(&self->lp_pppd, "call", (char *)ifname);

    /* Register to netlink update events */
    if (!lnx_netlink_init(&self->lp_nl, lnx_pppoe_netlink_fn))
    {
        LOG(ERR, "pppoe: %s: Error initializing netlink socket.", ifname);
        daemon_fini(&self->lp_pppd);
        return false;
    }

    lnx_netlink_set_ifname(&self->lp_nl, ifname);
    lnx_netlink_set_events(&self->lp_nl, LNX_NETLINK_LINK | LNX_NETLINK_IP4ADDR | LNX_NETLINK_IP6ADDR);

    return true;
}

bool lnx_pppoe_fini(lnx_pppoe_t *self)
{
    char fpath[C_MAXPATH_LEN];
    size_t rc;

    lnx_netlink_fini(&self->lp_nl);
    daemon_fini(&self->lp_pppd);
    lnx_pppoe_secret_del(self);

    /*
     * Delete the peers (configuration) file for this interface
     */
    rc = snprintf(fpath, sizeof(fpath), "%s/%s", LNX_PPPOE_PEERS_DIR, self->lp_ifname);
    if (rc < sizeof(fpath))
    {
        unlink(fpath);
    }

    return true;
}

bool lnx_pppoe_apply(lnx_pppoe_t *self)
{
    bool started;

    if (!daemon_is_started(&self->lp_pppd, &started) || started)
    {
        daemon_stop(&self->lp_pppd);
    }

    /* Update the peers file -- aka config file */
    if (!lnx_pppoe_peers_write(self))
    {
        LOG(ERR, "pppoe: %s: Error writing configuration file.", self->lp_ifname);
        return false;
    }

    /* Update secret files */
    lnx_pppoe_secret_update();

    return daemon_start(&self->lp_pppd);
}

void lnx_pppoe_status_notify(lnx_pppoe_t *self, lnx_pppoe_status_fn_t *fn)
{
    self->lp_status_fn = fn;

    if (fn != NULL)
    {
        if (!lnx_netlink_start(&self->lp_nl))
        {
            LOG(WARN, "pppoe: %s: Error starting netlink socket.", self->lp_ifname);
        }
    }
    else
    {
        if (!lnx_netlink_stop(&self->lp_nl))
        {
            LOG(WARN, "pppoe: %s: Error stopping netlink socket.", self->lp_ifname);
        }
    }
}

bool lnx_pppoe_parent_set(lnx_pppoe_t *self, const char *parent_ifname)
{
    if (strscpy(self->lp_pifname, parent_ifname, sizeof(self->lp_pifname)) < 0)
    {
        LOG(WARN, "pppoe: %s: Parent interface name %s is too long.",
                self->lp_ifname, parent_ifname);

        self->lp_pifname[0] = '\0';
        return false;
    }

    return true;
}

/*
 * Set the secret for this PPPoE link. Calling this function multiple times will
 * overwrite previous secrets.
 */
bool lnx_pppoe_secret_set(lnx_pppoe_t *self, const char *username, const char *password)
{
    struct lnx_pppoe_secret *ps;

    ps = ds_tree_find(&lnx_pppoe_secrets, self->lp_ifname);
    if (ps == NULL)
    {
        ps = calloc(1, sizeof(struct lnx_pppoe_secret));
        ASSERT(ps != NULL, "pppoe: Error allocating PPPoE secret.")
        ps->ps_remote = self->lp_ifname;
        ds_tree_insert(&lnx_pppoe_secrets, ps, ps->ps_remote);
    }

    if (username == NULL)
    {
        lnx_pppoe_secret_del(self);
        return true;
    }

    /*
     * Use the interface name as the remote name since it will be used as
     * 'remotename' in the pppd configuration file
     */
    if (strlen(username) >= sizeof(ps->ps_username))
    {
        LOG(ERR, "pppoe: %s: Error setting secret: username too long.", self->lp_ifname);
        lnx_pppoe_secret_del(self);
        return false;
    }

    if (strlen(password) >= sizeof(ps->ps_password))
    {
        LOG(ERR, "pppoe: %s: Error setting secret: password too long.", self->lp_ifname);
        lnx_pppoe_secret_del(self);
        return false;
    }

    STRSCPY(ps->ps_username, username);
    STRSCPY(ps->ps_password, password);

    return true;
}

void lnx_pppoe_secret_del(lnx_pppoe_t *self)
{
    struct lnx_pppoe_secret *ps;

    ps = ds_tree_find(&lnx_pppoe_secrets, self->lp_ifname);
    if (ps == NULL) return;

    ds_tree_remove(&lnx_pppoe_secrets, ps);
    memset(ps, 0x0, sizeof(*ps));
    free(ps);
    lnx_pppoe_secret_update();
}


/*
 * Update PPP "secret" files. 
 *
 * It is impossible to know in advance which authentication scheme will be used
 * so this function updates both pap-secrets and chap-secrets files.
 */
static void lnx_pppoe_secret_update(void)
{
    (void)lnx_pppoe_secret_write(LNX_PPPOE_PAP_SECRETS);
    (void)lnx_pppoe_secret_write(LNX_PPPOE_CHAP_SECRETS);
}

bool lnx_pppoe_secret_write(const char *secret_file)
{
    struct lnx_pppoe_secret *ps;
    int fd;
    FILE *f;

    fd = open(secret_file, O_CREAT | O_TRUNC | O_WRONLY, 0600);
    if (fd < 0)
    {
        LOG(ERR, "pppoe: Error opening secret file %s for writing: %s",
                secret_file, strerror(errno));
        return false;
    }

    f = fdopen(fd, "w");
    if (f == NULL)
    {
        LOG(ERR, "pppoe: Error opening secret file %s, fdopen() failed.",
                secret_file);
        close(fd);
        return false;
    }

    ds_tree_foreach(&lnx_pppoe_secrets, ps)
    {
        fprintf(f, "\"%s\"\t\"%s\"\t\"%s\"\t*\n",
                ps->ps_username, ps->ps_remote, ps->ps_password); 
    }

    fclose(f);

    return true;
}

/*
 * Write out the "peers" (aka configuration) file for this pppd instance
 */
bool lnx_pppoe_peers_write(lnx_pppoe_t *self)
{
    struct lnx_pppoe_secret *ps;
    char fpath[C_MAXPATH_LEN];
    size_t rc;
    FILE *f;
    int fd;

    if (self->lp_pifname[0] == '\0')
    {
        LOG(ERR, "pppoe: %s: Parent interface not set.", self->lp_ifname);
        return false;
    }

    ps = ds_tree_find(&lnx_pppoe_secrets, self->lp_ifname);

    rc = snprintf(fpath, sizeof(fpath), "%s/%s", LNX_PPPOE_PEERS_DIR, self->lp_ifname);
    if (rc >= sizeof(fpath))
    {
        LOG(ERR, "pppoe: %s: Peers configuration file name is too long.", self->lp_ifname);
        return false;
    }

    LOG(DEBUG, "pppoe: %s: Writing configuration to: %s", self->lp_ifname, fpath);

    fd = open(fpath, O_TRUNC | O_CREAT | O_WRONLY, 0600);
    if (fd < 0)
    {
        LOG(ERR, "pppoe: %s: Error creating configuration file %s: %s",
                self->lp_ifname, fpath, strerror(errno));
        return false;
    }

    f = fdopen(fd, "w");
    if (f == NULL)
    {
        LOG(ERR, "pppoe: %s: fdopen() failed when writing configuration.", self->lp_ifname);
        close(fd);
        return false;
    }

    fprintf(f, lnx_pppoe_peers_template,
            self->lp_pifname,
            self->lp_ifname,
            self->lp_ifname);

    if (ps != NULL)
    {
        fprintf(f, lnx_pppoe_peers_template_username, ps->ps_username);
    }

    fclose(f);

    return true;
}

/*
 * Poll the current interface status and call the status callback
 */
void lnx_pppoe_status_poll(lnx_pppoe_t *self)
{
    struct ifreq ifr;

    memset(&self->lp_status, 0, sizeof(self->lp_status));
    self->lp_status.ps_local_ip = OSN_IP_ADDR_INIT;
    self->lp_status.ps_remote_ip = OSN_IP_ADDR_INIT;

    self->lp_status.ps_ifname = self->lp_ifname;

    if (lnx_pppoe_ifreq(self->lp_ifname, SIOCGIFFLAGS, &ifr))
    {
        self->lp_status.ps_exists = true;
        self->lp_status.ps_carrier = ifr.ifr_flags & IFF_RUNNING;
    }

    if (lnx_pppoe_ifreq(self->lp_ifname, SIOCGIFMTU, &ifr))
    {
        self->lp_status.ps_mtu = ifr.ifr_mtu;
    }

    if (lnx_pppoe_ifreq(self->lp_ifname, SIOCGIFADDR, &ifr) &&
            !osn_ip_addr_from_sockaddr(&self->lp_status.ps_local_ip, &ifr.ifr_addr))
    {
        LOG(WARN, "pppoe: %s: Unable to parse local IP.", self->lp_ifname);
    }

    if (lnx_pppoe_ifreq(self->lp_ifname, SIOCGIFDSTADDR, &ifr) &&
            !osn_ip_addr_from_sockaddr(&self->lp_status.ps_remote_ip, &ifr.ifr_addr))
    {
        LOG(WARN, "pppoe: %s: Unable to parse local IP.", self->lp_ifname);
    }

    if (self->lp_status_fn != NULL)
    {
        self->lp_status_fn(self, &self->lp_status);
    }
}

void lnx_pppoe_netlink_fn(lnx_netlink_t *nl, uint64_t event, const char *ifname)
{
    (void)event;
    (void)ifname;

    lnx_pppoe_t *self = CONTAINER_OF(nl, lnx_pppoe_t, lp_nl);

    lnx_pppoe_status_poll(self);
}

/*
 * Issue an ioctl() on the specified interface
 */
bool lnx_pppoe_ifreq(const char *ifname, int cmd, struct ifreq *req)
{
    static int ifreq_socket = -1;

    if (ifreq_socket < 0)
    {
        ifreq_socket = socket(AF_INET, SOCK_DGRAM, 0);
        if (ifreq_socket < 0)
        {
            LOG(ERR, "pppoe: Unable to open ifreq socket.");
            return false;
        }
    }

    if (STRSCPY(req->ifr_name, ifname) < 0)
    {
        LOG(ERR, "pppoe: %s: ioctl() failed, interface name too long.", ifname);
        return false;
    }

    /* Issue ioctl() */
    if (ioctl(ifreq_socket, cmd, (void *)req) < 0)
    {
        LOG(DEBUG, "pppoe: %s: ioctl() failed.", ifname);
        return false;
    }

    return true;
}
